from typing import Tuple, Sequence, Union, Optional, Iterator

"""
Address
"""

class PyAddress:
    def __init__(self, addr: bytes) -> None: ...
    @classmethod
    def from_string(cls, string: str) -> PyAddress: ...
    @classmethod
    def from_params(cls, ver: int, identifier: bytes) -> PyAddress: ...
    def to_string(self) -> str: ...
    def version(self) -> int:
        """0b00000~0b11111 int"""
    def identifier(self) -> bytes:
        """20 bytes"""
    def binary(self) -> bytes:
        """21 bytes"""


"""
Tx
"""


TxInput = Tuple[bytes, int]
TxOutput = Tuple[PyAddress, int, int]


class PyTxInputs:
    def __init__(self, inputs: Sequence[TxInput]) -> None: ...
    def __iter__(self) -> Iterator[TxInput]: ...
    def len(self) -> int: ...
    def get(self, index: int) -> TxInput:
        """raise IndexError when out of bounds"""
    def tuple(self) -> Sequence[TxInput]: ...
    def add(self, hash: bytes, index: int) -> None: ...
    def push(self, unspent: PyUnspent) -> None: ...
    def pop(self, index: Optional[int]) -> TxInput: ...
    def extend(self, value: PyTxInputs) -> None: ...
    def clear(self) -> None: ...


class PyTxOutputs:
    def __init__(self, outputs: Sequence[TxOutput]) -> None: ...
    def __iter__(self) -> Iterator[TxOutput]: ...
    def len(self) -> int: ...
    def get(self, index: int) -> TxOutput:
        """raise IndexError when out of bounds"""
    def tuple(self) -> Sequence[TxOutput]: ...
    def add(self, addr: PyAddress, coin_id: int, amount: int) -> None: ...
    def replace(self, index: int, addr: PyAddress, coin_id: int, amount: int) -> None: ...
    def pop(self, index: Optional[int]) -> TxOutput: ...
    def extend(self, value: PyTxOutputs) -> None: ...
    def clear(self) -> None: ...


class PyTx:
    version: int
    txtype: int
    time: int
    deadline: int
    inputs: PyTxInputs
    outputs: PyTxOutputs
    gas_price: int
    gas_amount: int
    signature: Optional[PySignature]
    # time
    create_time: float

    def __init__(
            self,
            version: int,
            txtype: int,
            time: int,
            deadline: int,
            inputs: PyTxInputs,
            outputs: PyTxOutputs,
            gas_price: int,
            gas_amount: int,
            message_type: int,
            message: Optional[bytes],
    ) -> None: ...
    def hex(self) -> str: ...
    def hash(self) -> bytes: ...
    @classmethod
    def from_bytes(cls, binary: bytes) -> PyTx: ...
    @classmethod
    def template_for_staking(cls, version: int, unspent: PyUnspent) -> PyTx:
        """generate staking coinbase template"""
    def to_bytes(self) ->bytes: ...
    def get_message_type(self) -> int: ...
    def get_message_body(self) -> bytes: ...
    def replace_message(self, value: bytes) -> None: ...
    def fill_input_cache(self, ignore: bool, chain: PyChain) -> None: ...
    def get_input_cache(self) -> PyTxOutputs: ...
    def fill_verified_list(self) -> None: ...
    def get_verified_list(self) -> Sequence[PyAddress]: ...
    def get_fee(self, check: bool) -> PyBalance:
        """check means gas fee is same with calc balance and raise ValueError **if** mismatch"""
    def get_size(self) -> int: ...
    def getinfo(self) -> dict: ...


"""
Block
"""

# txhash list or tx object list
PyTxsItemType = Union[bytes, PyTx]
PyTxsListType = Union[Sequence[bytes], Sequence[PyTx]]

class PyTxs:
    """Block's txs object"""
    HASH: str = "hash"
    OBJECT: str = "object"
    def __init__(self, typename: str, txs: PyTxsListType) -> None: ...
    def __iter__(self) -> Iterator[PyTxsItemType]: ...
    def len(self) -> int: ...
    def typename(self) -> str: ...
    def get(self, index: int) -> PyTxsItemType: ...
    def index(self, obj: PyTxsItemType) -> int: ...
    def contain(self, obj: PyTxsItemType) -> bool: ...
    def push(self, obj: PyTxsItemType) -> None: ...
    def insert(self, index: int, obj: PyTxsItemType) -> None: ...
    def extend(self, txs: PyTxs) -> None: ...
    def remove(self, index: int) -> None: ...
    def pop(self) -> PyTxsItemType: ...
    def get_hash_list(self) -> Sequence[bytes]: ...
    def convert_object_type(self, chain: PyChain) -> None:
        """convert hash to object type, skip if already object type"""


class PyBlock:
    """default read only (except work_hash and tx_hash)"""
    # meta
    work_hash: Optional[bytes]
    height: int
    flag: int
    bias: int
    # header
    version: int
    previous_hash: bytes
    merkleroot: bytes
    time: int
    bits: int
    nonce: int
    # body
    txs: PyTxs
    # time
    create_time: float

    def __init__(
            self,
            # meta
            height: int,
            flag: int,
            bias: float,
            # header
            version: int,
            previous_hash: bytes,
            time: int,
            bits: int,
            nonce: int,
            # body
            txs: PyTxs
    ) -> None: ...
    @classmethod
    def from_bytes(
            cls,
            height: int,
            flag: int,
            bias: float,
            binary: bytes,
            txs: PyTxs,
    ) -> PyBlock: ...
    def to_bytes(self) ->bytes: ...
    def hex(self) -> str: ...
    def hash(self) -> bytes: ...
    def two_difficulties(self) -> Tuple[float, float]:
        """:returns: (required, work)"""
    def update_merkleroot(self) -> None: ...
    def check_proof_of_work(self) -> bool: ...
    def update_time(self, time: int) -> None: ...
    def update_nonce(self, nonce: int) -> None: ...
    def increment_nonce(self) -> None: ...
    def get_size(self) -> int: ...
    def getinfo(self) -> dict: ...


"""
Signature
"""

class PySignature:
    SINGLE: int = 0
    AGGREGATE: int = 1
    THRESHOLD: int = 2

    def __init__(self) -> None: ...
    def get_binary_list(self) -> Sequence[bytes]: ...
    def add_from_params(self, stype: int, params: Sequence[bytes]) -> None: ...
    def add_from_binary(self, binary: bytes) -> None: ...
    def get_size(self) -> int: ...
    def len(self) -> int: ...


"""
Unspent
"""

class PyUnspent:
    txhash: bytes
    txindex: int
    address: PyAddress
    coin_id: int
    amount: int

"""
Account
"""

class PyBalance:
    def __init__(self, balance: Optional[Sequence[Tuple[int, int]]]) -> None: ...
    def __iter__(self) -> Iterator[Tuple[int, int]]: ...
    def __add__(self, other: PyBalance) -> PyBalance: ...
    def __sub__(self, other: PyBalance) -> PyBalance: ...
    def get_amount(self, coin_id: int) -> int: ...
    def add_amount(self, coin_id: int, amount: int) -> None: ...
    def sub_amount(self, coin_id: int, amount: int) -> None: ...
    def add_balance(self, other: PyBalance) -> None: ...
    def sub_balance(self, other: PyBalance) -> None: ...
    def is_all_plus(self) -> bool:
        """check all balances' amount is plus or zero"""
    def is_empty(self) -> bool:
        """check all balances' amount is zero"""


class PyMovement:
    hash: bytes
    type: str
    height: Optional[int]
    position: Optional[int]
    movement: Sequence[Tuple[int, PyBalance]]
    fee: PyBalance


class PyAccount:
    account_id: int
    confirmed: PyBalance
    unconfirmed: PyBalance


"""
Chain
"""


class PyChain:
    is_closed: bool

    def __init__(
            self,
            root_dir: str,
            sk: Optional[bytes],
            deadline: int,
            tx_index: bool,
            addr_index: bool
    ) -> None: ...
    def push_new_block(self, block: PyBlock) -> None: ...
    def push_unconfirmed(self, tx: PyTx) -> None: ...
    def get_block(self, hash: bytes) -> Optional[PyBlock]: ...
    def get_full_block(self, hash: bytes) -> Optional[PyBlock]: ...
    def get_best_block(self, full: bool) -> PyBlock: ...
    def get_tx(self, hash: bytes) -> Optional[PyTx]: ...
    def get_account_balance(self, account_id: int, confirm: int) -> PyAccount: ...
    def get_account_address(self, account_id: int, new: bool) -> PyAddress:
        """get unused address by id, **new** flag force return addr not generated by user yet"""
    def get_account_addr_path(self, addr: PyAddress) -> Tuple[int, int, int]:
        """find address derive path **m/44'/CoinType'/account'/is_inner/index**"""
    def calc_unspent_by_amount(self, balances: PyBalance) -> Sequence[PyUnspent]: ...
    def list_unspent_by_addr(self, addrs: Sequence[PyAddress], page: int, size: int) -> Sequence[PyUnspent]: ...
    def list_unspent_for_staking(self, mature_height: int, limit: int)-> Tuple[Sequence[PyUnspent], int]: ...
    def list_account_movement(self, page: int, size: int) -> Sequence[PyMovement]: ...
    def close(self) -> None: ...


# diff param (flag, T, N, K)
BlockTimeParams = Sequence[Tuple[int, int, int, int]]


class PyDiffBuilder:
    def __init__(self, params: BlockTimeParams, chain: PyChain) -> None: ...
    def calc_next_bits(self, previous_hash: bytes, flag: int) -> int:...
    def calc_next_bias(self, previous_hash: bytes, flag: int) -> float: ...
    @staticmethod
    def bits_to_target(bits: int) -> bytes: ...
    @staticmethod
    def target_to_bits(target: bytes) -> int: ...
    @staticmethod
    def target_to_diff(target: bytes) -> float: ...


class PyValidate:
    def __init__(self, chain: PyChain) -> None: ...
    def is_unconfirmed(self, hash: bytes) -> bool:
        """**true** means the txhash is unconfirmed but **false** means confirmed or not exist"""
    def is_mature_input(self, base_hash: bytes, limit_height: int) -> bool:
        """this method is designed for PoS coinbase tx's input check"""
    def is_unused_inputs(self, inputs: PyTxInputs, except_hash: bytes, best_block: Optional[PyBlock]) -> bool:
        """check inputs already used on both unconfirmed and confirmed status, return **true** means valid"""
    def is_orphan_block(self, block: PyBlock) -> bool:
        """check the block included by best_chain or recoded to tables and indexed"""
    def clear_old_unconfirmed(self, deadline: int) -> int:
        """remove expired unconfirmed txs by deadline and return removed count"""
    def get_best_unconfirmed(self, maxsize: int) -> PyTxs:
        """get list of unconfirmed tx's hash list for mining"""
